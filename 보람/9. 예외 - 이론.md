## 예외 처리가 필요한 이유

### NetworkServiceV0

간단한 프로그램 예제를 통해 예외 처리가 왜 필요한지 이해할 수 있음. 예제는 네트워크 연결을 시뮬레이션하며, 정상적인 상황에서는 데이터를 서버에 전송하고 연결을 종료함.

**예제 코드:**

```java
package exception.ex0;

public class NetworkClientV0 {
    private final String address;

    public NetworkClientV0(String address) {
        this.address = address;
    }

    public String connect() {
        System.out.println(address + " 서버 연결 성공");
        return "success";
    }

    public String send(String data) {
        System.out.println(address + " 서버에 데이터 전송: " + data);
        return "success";
    }

    public void disconnect() {
        System.out.println(address + " 서버 연결 해제");
    }
}
```

### 오류 상황 만들기

외부 서버와의 통신에서 발생할 수 있는 오류 상황을 시뮬레이션. 사용자가 특정 문자열을 입력하면, 연결 실패 또는 데이터 전송 실패를 시뮬레이션함.

**예제 코드:**

```java
package exception.ex1;

public class NetworkClientV1 {
    private final String address;
    public boolean connectError;
    public boolean sendError;

    public NetworkClientV1(String address) {
        this.address = address;
    }

    public String connect() {
        if (connectError) {
            System.out.println(address + " 서버 연결 실패");
            return "connectError";
        }
        System.out.println(address + " 서버 연결 성공");
        return "success";
    }

    public String send(String data) {
        if (sendError) {
            System.out.println(address + " 서버에 데이터 전송 실패: " + data);
            return "sendError";
        }
        System.out.println(address + " 서버에 데이터 전송: " + data);
        return "success";
    }

    public void disconnect() {
        System.out.println(address + " 서버 연결 해제");
    }

    public void initError(String data) {
        if (data.contains("error1")) {
            connectError = true;
        }
        if (data.contains("error2")) {
            sendError = true;
        }
    }
}
```

### 반환 값으로 예외 처리

`NetworkClientV1` 클래스에서 오류를 반환 값으로 처리하는 방법을 보여줌. 이는 예외 처리의 기초적인 방법으로, 더 나은 예외 처리 방법을 배우기 위한 기초를 제공함.

---

## 정상 흐름과 예외 흐름

정상 흐름과 예외 흐름을 분리하는 것이 중요한 이유는 코드의 가독성을 높이고, 예외 발생 시 프로그램이 어떻게 동작할지를 명확하게 이해할 수 있게 하기 때문임. 이 문서에서는 반환 값 기반의 예외 처리에서 발생하는 문제를 보여주고, 자바의 예외 처리 메커니즘을 사용하는 방법을 설명함.

---

## 자바 예외 처리

### 예외 계층

자바는 `Throwable`을 상위 클래스로 하여 예외를 계층적으로 관리함. `Exception`과 `Error`가 그 하위 클래스이며, `Exception`은 다시 체크 예외와 언체크 예외로 나뉨.

- **Throwable:** 모든 예외의 최상위 클래스. 이 클래스는 예외 처리를 위해 존재하는 모든 클래스의 부모 클래스.
- **Error:** 애플리케이션 코드에서 복구할 수 없는 심각한 문제를 나타냄. 예를 들어, 메모리 부족이나 시스템 크래시 같은 문제. 이런 문제들은 애플리케이션에서 예외 처리로 해결할 수 없으므로, 일반적으로 개발자가 이 예외를 처리하려고 하지 않음.
- **Exception:** 애플리케이션에서 발생할 수 있는 다양한 예외를 나타냄. `Exception` 클래스는 일반적으로 애플리케이션에서 처리할 수 있는 문제들을 나타내며, 체크 예외와 언체크 예외로 구분됨.

### 예외 기본 규칙

예외는 처리하거나, 처리할 수 없다면 호출한 쪽으로 던져야 함. 자바에서는 이 두 가지 규칙을 통해 예외를 다룸.

- **예외 처리:** try-catch 블록을 통해 예외를 처리함.
- **예외 던지기:** 예외를 처리하지 못할 경우, throws 키워드를 사용하여 호출자에게 예외를 전달함.

### 체크 예외

체크 예외는 반드시 처리해야 하는 예외임. 이 예외는 컴파일러가 체크하며, 처리하지 않을 경우 컴파일 오류가 발생함.

**예제 코드:**

```java
package exception.basic.checked;

public class MyCheckedException extends Exception {
    public MyCheckedException(String message) {
        super(message);
    }
}
```

### 언체크 예외

언체크 예외는 `RuntimeException`을 상속받은 예외로, 반드시 처리하지 않아도 됨. 컴파일러가 체크하지 않기 때문에 `throws` 선언 없이 사용할 수 있음.

**예제 코드:**

```java
package exception.basic.unchecked;

public class MyUncheckedException extends RuntimeException {
    public MyUncheckedException(String message) {
        super(message);
    }
}
```

---

## 추가적인 개념과 주의사항

### 예외 처리의 목적

예외 처리는 프로그램의 예측 불가능한 상황에 대처하기 위한 방법임. 예외 처리를 통해 프로그램이 예상치 못한 상황에서도 정상적으로 종료될 수 있도록 하고, 사용자에게 의미 있는 오류 메시지를 제공할 수 있음.

### 체크 예외 vs 언체크 예외

- **체크 예외:** 컴파일러가 체크하며, 반드시 처리해야 하는 예외. 예외 발생 시 반드시 try-catch로 처리하거나 throws로 던져야 함.
- **언체크 예외:** 컴파일러가 체크하지 않으며, 선택적으로 처리할 수 있는 예외. 일반적으로 프로그래머의 실수로 발생하는 예외들이 여기에 속함.

### 예외 처리의 Best Practice

- **정상 흐름과 예외 흐름을 분리**: 예외 처리를 명확하게 하여 정상적인 코드 흐름을 유지하고, 예외가 발생했을 때 예외 처리 블록에서 이를 명확하게 처리하도록 함.
- **의미 있는 예외 메시지 제공**: 예외가 발생했을 때, 개발자나 사용자에게 의미 있는 메시지를 제공하여 문제를 쉽게 파악할 수 있도록 함.
- **자원 해제**: 예외가 발생하더라도 자원이 정상적으로 해제될 수 있도록 `finally` 블록을 사용하거나, 자바 7 이후의 `try-with-resources` 구문을 활용하는 것이 좋음.

