## 예외 처리 도입

### 예외 처리 도입1 - 시작

초기에는 반환 값을 사용하여 예외를 처리했음. 이는 코드가 복잡해지고, 정상 흐름과 예외 흐름이 혼재되어 가독성이 떨어지는 문제가 발생함. 이 문제를 해결하기 위해 자바의 예외 처리 기능을 도입함.

**예제 코드:**

```java
public class NetworkClientExceptionV2 extends Exception {
    private String errorCode;

    public NetworkClientExceptionV2(String errorCode, String message) {
        super(message);
        this.errorCode = errorCode;
    }

    public String getErrorCode() {
        return errorCode;
    }
}
```

이 코드는 특정 예외 상황에서 오류 코드를 포함한 예외를 생성하고, 이 예외를 통해 오류를 처리하도록 함.

### 예외 처리 도입2 - 예외 복구

예외가 발생했을 때 예외를 잡아 정상 흐름으로 복구하는 방법을 설명함. `try-catch` 블록을 사용하여 예외를 잡고, 예외 메시지를 출력하거나 필요한 경우 반환 값을 통해 흐름을 제어함.

**예제 코드:**

```java
try {
    client.connect();
} catch (NetworkClientExceptionV2 e) {
    System.out.println("[오류] 코드: " + e.getErrorCode() + ", 메시지: " + e.getMessage());
}
```

### 예외 처리 도입3 - 정상, 예외 흐름 분리

예외 처리의 `try-catch` 기능을 활용하여 정상 흐름과 예외 흐름을 명확하게 분리함으로써 코드의 가독성을 높이는 방법을 설명함.

**예제 코드:**

```java
try {
    client.connect();
    client.send(data);
    client.disconnect();
} catch (NetworkClientExceptionV2 e) {
    System.out.println("[오류] 코드: " + e.getErrorCode() + ", 메시지: " + e.getMessage());
}
```

### 예외 처리 도입4 - 리소스 반환 문제

예외가 발생하더라도 자원을 적절하게 반환하는 방법을 설명함. `finally` 블록을 사용하여 자원 반환을 보장함.

**예제 코드:**

```java
try {
    client.connect();
    client.send(data);
} catch (NetworkClientExceptionV2 e) {
    System.out.println("[오류] 코드: " + e.getErrorCode() + ", 메시지: " + e.getMessage());
} finally {
    client.disconnect();
}
```

### 예외 처리 도입5 - finally

`finally` 블록은 `try` 블록이 끝난 후 항상 실행되며, 예외가 발생하더라도 반드시 실행되는 코드를 작성할 수 있음. 이 방법을 통해 자원 해제를 보장함.

**예제 코드:**

```java
try {
    client.connect();
    client.send(data);
} catch (NetworkClientExceptionV2 e) {
    System.out.println("[오류] 코드: " + e.getErrorCode() + ", 메시지: " + e.getMessage());
} finally {
    client.disconnect();
}
```

---

## 예외 계층

### 예외 계층1 - 시작

자바의 예외 계층 구조를 활용하여 예외를 세분화하고, 특정 예외를 처리할 수 있는 방법을 설명함.

**예제 코드:**

```java
public class ConnectExceptionV3 extends NetworkClientExceptionV3 {
    private final String address;

    public ConnectExceptionV3(String address, String message) {
        super(message);
        this.address = address;
    }

    public String getAddress() {
        return address;
    }
}
```

### 예외 계층2 - 활용

예외 계층을 활용하여 특정 예외를 구체적으로 처리하거나, 상위 예외로 처리할 수 있는 방법을 설명함. 이를 통해 코드의 재사용성을 높이고, 예외 처리를 더욱 유연하게 함.

**예제 코드:**

```java
try {
    client.connect();
} catch (ConnectExceptionV3 e) {
    System.out.println("[연결 오류] 주소: " + e.getAddress() + ", 메시지: " + e.getMessage());
} catch (NetworkClientExceptionV3 e) {
    System.out.println("[네트워크 오류] 메시지: " + e.getMessage());
} catch (Exception e) {
    System.out.println("[알 수 없는 오류] 메시지: " + e.getMessage());
} finally {
    client.disconnect();
}
```

---

## 실무 예외 처리 방안

### 체크 예외 사용 시나리오

체크 예외는 컴파일러가 체크하는 예외로, 반드시 처리해야 하는 예외임. 그러나 실무에서는 모든 예외를 체크 예외로 처리하기 어렵고, 코드가 복잡해지는 문제를 야기함. 이 문제를 해결하기 위해 체크 예외를 사용하는 구체적인 시나리오를 설명함.

### 언체크 예외 사용 시나리오

언체크 예외는 `RuntimeException`을 상속받은 예외로, 선택적으로 처리할 수 있음. 실무에서 체크 예외 대신 언체크 예외를 사용하면 코드가 단순해지고, 예외 처리가 필요한 부분만 선택적으로 처리할 수 있음.

**예제 코드:**

```java
public class NetworkClientExceptionV4 extends RuntimeException {
    public NetworkClientExceptionV4(String message) {
        super(message);
    }
}
```

---

## 추가적인 개념과 주의사항

### Try-with-resources

자바 7에서 도입된 `Try-with-resources` 구문은 외부 자원을 사용할 때 자원 누수를 방지하기 위해 `AutoCloseable` 인터페이스를 구현한 객체를 사용하도록 설계됨. 이를 통해 자원을 자동으로 해제할 수 있으며, 코드의 가독성과 안정성을 높임.

**예제 코드:**

```java
try (NetworkClientV5 client = new NetworkClientV5(address)) {
    client.connect();
    client.send(data);
} catch (Exception e) {
    System.out.println("[예외 확인]: " + e.getMessage());
}
```

### 예외 공통 처리

예외를 공통으로 처리하는 방법을 통해, 각 예외를 개별적으로 처리하지 않고, 하나의 메서드에서 모든 예외를 일괄적으로 처리할 수 있는 방법을 설명함. 이를 통해 코드의 복잡성을 줄이고, 유지보수를 쉽게 할 수 있음.

**예제 코드:**

```java
try {
    networkService.sendMessage(input);
} catch (Exception e) {
    exceptionHandler(e);
}
```

